<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 关于React的一些实践思考与总结 · Web前端爱好者</title><meta name="description" content="关于React的一些实践思考与总结 - SkyCai"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://cnt1992.github.io/atom.xml" title="Web前端爱好者"><meta name="generator" content="Hexo 7.0.0"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/cnt1992" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><span style="display:none !important;"><span id="busuanzi_container_page_pv">本文总阅读量<span id="busuanzi_value_page_pv"></span></span></span><article class="post-block"><h1 class="post-title">关于React的一些实践思考与总结</h1><div class="post-info">2016年8月6日</div><div class="post-content"><p>本文不是关于 <code>React</code> 的入门介绍教程，假设还没有对 <code>React</code> 这门技术有所了解或者没有真正在项目中实践过的童鞋可以移步 <a href="https://facebook.github.io/react/">React官网</a> 或者 <a href="http://reactjs.cn/">React中文网</a>，推荐看阮一峰的 <a href="http://www.ruanyifeng.com/blog/2015/03/react.html">React入门实例教程</a>。对 <code>React</code> 有实际项目的应用并且也用过 <code>Redux</code>&#x2F;<code>Flux</code>&#x2F;<code>Reflux</code> 其中的一个或者多个框架开发过应用的童鞋欢迎共同 <del>吐槽</del><br><strong>探讨</strong> 关于 <code>React</code> 这门技术使用过程中碰到的问题以及一些总结。</p>
<p>最近这段时间用了 <code>Flux</code> 跟 <code>Redux</code> 这两个框架开发 <code>React</code> 应用，并且完全用 <code>ES6</code> 语法开发，利用 <code>Webpack</code> 作为脚手架结合 <code>Babel</code> 编译成向下兼容的脚本。在实际项目开发过程中，碰到的问题挺多，所以才有了此文。</p>
<span id="more"></span>

<h2 id="如何保护进程不因React脚本错误而终止"><a href="#如何保护进程不因React脚本错误而终止" class="headerlink" title="如何保护进程不因React脚本错误而终止"></a>如何保护进程不因React脚本错误而终止</h2><p>近些年一直被业界推崇的<code>组件化</code>开发，用<code>React</code>开发起来还是挺不错的，一个页面用多个组件堆砌起来，组件能够复用，但这个时候会碰到一个问题，在开发的过程中如果某一个组件报错了，那么这个页面就会被直接抛出错误而导致Crash，其他组件也直接不渲染出来。</p>
<p>这样子我们在控制台里面只会看到报错的内容以及官方的链接让你去解决问题，其实不能直观让我们知道是哪一个组件报错了。而且从<code>分而治之</code>的思想来看，组件与组件之间不应该直接相互干扰，一个组件报错也不应该导致其他组件直接不渲染了，那么最好的方法就是直接用 <code>装饰者模式</code> 给 <code>React</code> 带上美丽的装饰。</p>
<p>每一个<code>React</code>组件都会调用<code>createElement</code>方法生成组件，那么只需要在这个地方做文章即可，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> safe <span class="keyword">from</span> <span class="string">&#x27;./Safe&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> _func = <span class="title class_">React</span>.<span class="property">createElement</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">React</span>.<span class="property">createElement</span> = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> args[<span class="number">0</span>] === <span class="string">&#x27;function&#x27;</span> &amp;&amp; !args[<span class="number">0</span>].<span class="property">_isSafe</span>) &#123;</span><br><span class="line">        <span class="title function_">safe</span>(args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码将<code>React.createElement</code>由<code>safe</code>方法来接管，那么这个时候我们就有办法在<code>Safe.js</code>里面保证在<code>createElement</code>的时候不直接因为报错而导致页面Crash，只要把会报错的生命周期的其中两个：<code>componentWillMount</code>&#x2F;<code>render</code>改写一些即可，大致如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">safe</span> (target) &#123;</span><br><span class="line">    <span class="keyword">let</span> p = target.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">    <span class="keyword">let</span> list = [</span><br><span class="line">        <span class="string">&#x27;render&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;componentWillMount&#x27;</span></span><br><span class="line">    ];</span><br><span class="line">    list.<span class="title function_">forEach</span>(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name <span class="keyword">in</span> p &amp;&amp; <span class="keyword">typeof</span> p[name] === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> _func = p[name];</span><br><span class="line">            p[name] = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> _func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                    <span class="comment">// 这里捕捉到React渲染报错，你可以啥都不做</span></span><br><span class="line">                    <span class="comment">// 也可以将错误信息直接渲染在页面 </span></span><br><span class="line">                    <span class="comment">// ErrorResult是你自定义的错误展示组件 msg是你自定义的错误信息</span></span><br><span class="line">                    <span class="keyword">const</span> error = &#123;</span><br><span class="line">                        msg</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="keyword">return</span> (</span><br><span class="line">                        <span class="language-xml"><span class="tag">&lt;<span class="name">ErrorResult</span> &#123;<span class="attr">error</span>&#125; &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    target.<span class="property">_isSafe</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种<code>Safe</code>机制极大帮助我们快速知道哪个组件有问题，减少定位问题组件的时间成本，上面这种方案也是我们项目基于<code>Redux</code>的基础上封装成的基础<code>SDK</code>，基于这个<code>SDK</code>上进行页面的组件堆砌。</p>
<h2 id="关于传值与传址的问题"><a href="#关于传值与传址的问题" class="headerlink" title="关于传值与传址的问题"></a>关于传值与传址的问题</h2><p>这个其实<code>Javascript</code>里面已经说得非常清楚，简单复习一些<strong>传值</strong>与<strong>传址</strong>的区别，一个简单的Demo即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传值是Javascript基本数据类型（数字、字符串、布尔值）被操作的过程</span></span><br><span class="line"><span class="comment">// 实际上是拷贝了一份存在另一个变量里面，相互不干扰</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">666</span>, </span><br><span class="line">    b = a;</span><br><span class="line">b = <span class="number">555</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);  <span class="comment">// 666</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 而传址在Javascript中主要指针对引用类型(对象、数组、函数)的值的操作过程</span></span><br><span class="line"><span class="comment">// 虽然也拷贝了一份存在另一个变量里面，但副本指针指向跟原本同一个位置</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="title class_">Object</span>(),</span><br><span class="line">    d = c;</span><br><span class="line">c.<span class="property">name</span> = <span class="string">&#x27;SkyCai&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d.<span class="property">name</span>);   <span class="comment">// &#x27;SkyCai&#x27;</span></span><br></pre></td></tr></table></figure>

<p>简单描述一下我在项目需要实现的需求：无线端页面往下拉到差不多最底部的时候触发一次异步请求拿到下一页的数据，但由于我们的整个页面数据是由<code>SDK</code>进行管控的，这个时候就需要将请求拿到的数据跟之前的数据进行合并之后触发一次<code>SDK</code>提供的<code>updateStore</code>方法去更新<code>store</code>里面的数据，然后<code>增量更新</code>页面数据从而渲染。</p>
<p>简单看下我一开始写下的核心代码逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于存储页面合并之后的数据</span></span><br><span class="line"><span class="keyword">var</span> pageData = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟加载第一页数据</span></span><br><span class="line"><span class="title function_">loadData</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟加载第二页数据</span></span><br><span class="line"><span class="title function_">loadData</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟加载第三页数据</span></span><br><span class="line"><span class="title function_">loadData</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loadData</span>(<span class="params">page</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> promise = xxx; <span class="comment">// promise请求</span></span><br><span class="line">    promise.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">res</span>)&#123;</span><br><span class="line">        <span class="comment">// res是一个对象</span></span><br><span class="line">        <span class="keyword">if</span> (res.<span class="property">success</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pageData.<span class="property">data</span>) &#123;</span><br><span class="line">                <span class="comment">// 初次请求直接就赋值给pageData</span></span><br><span class="line">                pageData = res.<span class="property">data</span>;</span><br><span class="line">                <span class="comment">// 初次请求直接渲染页面</span></span><br><span class="line">                <span class="title function_">renderPage</span>(pageData);          </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 后面的请求就将请求回来的数据合并到之前保存的数据里面</span></span><br><span class="line">                <span class="title class_">Object</span>.<span class="title function_">assign</span>(pageData, res.<span class="property">data</span>);</span><br><span class="line">                <span class="comment">// 后面合并数据之后触发updateStore更新store数据</span></span><br><span class="line">                <span class="title function_">updateStore</span>(pageData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="keyword">function</span>(<span class="params">err</span>)&#123;</span><br><span class="line">        <span class="comment">// err handle</span></span><br><span class="line">    &#125;);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乍看之下因为没什么问题了，But，任凭你怎么刷新页面永远都是第一次渲染出来，后面的就不管你了。</p>
<p>首先，犯了一个很低级的错误，关于<code>cloneDeep</code>的问题，翻一下 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">MDN文档</a> 可以知道 <code>Object.assign(target, ...sources)</code> 是浅拷贝的，也就是我上面第二次请求回来的数据合并之后并不是正确的数据，因为<code>res.data</code>里面还有多层<code>object</code>，这个容易解决，写一个<code>cloneDeep</code>方法实现即可，这里就不再贴出代码。</p>
<p>合并之后的数据正确了，但是触发<code>updateStore</code>的时候也碰到一个问题，那就是第一次触发<code>updateStore</code>的时候能够正确拿到数据并且渲染第二页的数据，但是再次触发的时候就不渲染第三页的数据了。这就是提到的关于<strong>传值</strong>跟<strong>传址</strong>的问题，当第一次触发<code>updateStore</code>的时候传了一个<code>object</code>过去，后面再合并数据之后同样传了一个<code>object</code>过去，但这个<code>object</code>是基于上一个<code>object</code>的基础上复制的，所以导致了指向同一个指针，最简单粗暴的方法就是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单粗暴的让pageData变成值传递过去</span></span><br><span class="line"><span class="title function_">updateStore</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(pageData))); </span><br></pre></td></tr></table></figure>

<h2 id="尽量避免写依赖函数名的代码"><a href="#尽量避免写依赖函数名的代码" class="headerlink" title="尽量避免写依赖函数名的代码"></a>尽量避免写依赖函数名的代码</h2><p>啥意思？接着上面那个问题，<code>updateStore</code>实际上是触发了<code>updateStoreAction</code>对<code>store</code>进行更新的，来看一下<code>updateStoreAction</code>的核心代码逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateStoreData</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        type : <span class="string">&#x27;UPDATESTORE&#x27;</span>,</span><br><span class="line">        data : data</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> updateStoreAction = <span class="keyword">function</span> <span class="title function_">updateStoreAction</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">dispatch, getState</span>) =&gt;</span> &#123;        </span><br><span class="line">        <span class="title function_">dispatch</span>(<span class="title function_">updateStoreData</span>(data));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> updateStoreAction;</span><br></pre></td></tr></table></figure>

<p>上面代码逻辑还是很清晰的，如果接受到<code>UPDATESTORE</code>的<code>type</code>时就<code>dispatch</code>出去<code>updateStoreData</code>，这个时候这个<code>dispatch</code>走到<code>SDK</code>里面的一段逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上面的updateStoreAction会传入到Config.actionMiddlewareList</span></span><br><span class="line"><span class="keyword">let</span> middleware = <span class="title class_">Config</span>.<span class="property">actionMiddlewareList</span> || [];</span><br><span class="line">middleware.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">mw</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> funcName = mw.<span class="property">name</span>; <span class="comment">// 这里拿出函数名字，也就是updateStoreAction</span></span><br><span class="line">    <span class="keyword">if</span>(!funcName) &#123;</span><br><span class="line">        funcName = mw.<span class="title function_">toString</span>().<span class="title function_">match</span>(<span class="regexp">/^function\s*([^\s(]+)/</span>)[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">ModularizationActions</span>[funcName] = mw;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候看到<code>SDK</code>里面有一段代码依赖于函数名字了，那么问题就来了，在本地开启<code>webpack-dev-server</code>进行开发的时候没啥问题，但是提交生产环境的代码上去之后问题就来了。</p>
<p>这个“锅”让<code>webpack</code>来背比较好，看下面一段配置：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.<span class="title function_ invoke__">UglifyJsPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">compress</span>: &#123;</span><br><span class="line">        <span class="attr">warnings</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">minimize</span>: <span class="literal">true</span></span><br><span class="line">    &#125;),</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>生产环境下我们会压缩JS代码，但<code>webpack</code>官方文档没有详细对<code>UglifyJsPlugin</code>的参数进行解释，含糊的说默认情况下不进行开启<strong>代码混淆</strong>，也就是你不声明的话就不混淆，但实际上默认是进行了代码混淆，有兴趣的童鞋可以试试看<code>build</code>之后的代码。</p>
<p>基本解决方法当然是在<code>webpack</code>配置上将参数配好，增加一个参数：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.<span class="title function_ invoke__">UglifyJsPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">compress</span>: &#123;</span><br><span class="line">        <span class="attr">warnings</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">mangle</span>: <span class="literal">false</span>, // 代码不进行混淆</span><br><span class="line">      <span class="attr">minimize</span>: <span class="literal">true</span></span><br><span class="line">    &#125;),</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>但是我们仔细思考一下，怪<code>webpack</code>？作为基础<code>SDK</code>依赖于函数名进行操作其实是非常不合理的，底层通用脚手架必然承当更大的使命，所以当然要对依赖函数名字的代码进行重构才行，这才是解决问题本质的方法。</p>
<h2 id="关于Redux-Flux-Reflux框架选型思考"><a href="#关于Redux-Flux-Reflux框架选型思考" class="headerlink" title="关于Redux&#x2F;Flux&#x2F;Reflux框架选型思考"></a>关于Redux&#x2F;Flux&#x2F;Reflux框架选型思考</h2><p>经过对这三个框架实际项目的实践来看，个人而言，难易程度以此为：Redux &gt; Flux &gt; Reflux。当然这只是个人见解，不同的人使用起来感触都有所不同。</p>
<p>盗图(若侵权请联系我删除)来对比一下这三个框架的区别：</p>
<ul>
<li>Flux</li>
</ul>
<p><code>Flux</code>是<code>Facebook</code>官方实现的一套框架，基本上整个流程都已经有了，但是感觉操作起来还是挺麻烦，你每次增加一个功能都得改很多个文件，准确来说它应该是一种模式，基于此模式才有了Reflux跟Redux等优秀框架的出现。</p>
<p><img src="/img/think-of-react/flux.png" alt="flux流程图"></p>
<ul>
<li>Reflux</li>
</ul>
<p>流程相对简单，操作起来也非常方便。</p>
<p><img src="/img/think-of-react/reflux.png" alt="flux流程图"></p>
<ul>
<li>Redux</li>
</ul>
<p>这个社区应该是最多人在用了的，<code>单一数据源</code>&#x2F;<code>Store是只读的</code>&#x2F;<code>使用纯函数来进行修改</code> 这三个原则是<code>Redux</code>的最大特点。但就是由于<code>单一数据源</code>，所有的数据都存储在同一个<code>object tree</code>里面导致了调试很麻烦，跟<code>Flux</code>一样，增加一个功能你也得改很多个文件。</p>
<p><img src="/img/think-of-react/redux.jpeg" alt="redux流程图"></p>
<p>所以根据不同业务场景使用恰当的框架才是最正确的解锁方式，不要为了使用框架而使用框架。而且也不要盲目地看这个好用这个，根据业务定制最好的框架。而且，你不可能实现一个简简单单的需求就动辄用一个那么大的框架进来吧？</p>
<h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p><code>React</code>出来也一年多，涵盖了<code>web</code>&#x2F;<code>IOS</code>&#x2F;<code>Android</code>三端，社区也很火。有人看好有人看衰，有人说前端越来越浮躁，又有人喊web标准一去不复返。但我觉得框架亦或是工具只是为我们提供便利加速开发的，是我们在使用它们而不是它们在控制我们。所以，适合就用，不适合就不用，没有必要跟大众走。</p>
<p>嗯，用<code>ES6</code>写<code>React</code>还是爽！</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/08/10/replace-highlevel-function-width-mixins-in-react/" class="prev">PREV</a><a href="/2016/07/07/tmall-recruit/" class="next">NEXT</a></div><div id="gitment_title" onClick="showGitment()" class="gitment_title">显示评论</div><div id="J_commentContainer" style="display:none;"></div><link rel="stylesheet" href="//imsun.github.io/gitment/style/default.css"><script src="//imsun.github.io/gitment/dist/gitment.browser.js"></script><script>const myTheme = {
    render(state, instance) {
        const container = document.createElement('div');
        container.lang = "en-US";
        container.className = 'gitment-container gitment-root-container';
        container.appendChild(instance.renderHeader(state, instance));
        container.appendChild(instance.renderEditor(state, instance));
        container.appendChild(instance.renderComments(state, instance));
        container.appendChild(instance.renderFooter(state, instance));
        return container;
    }
}
function showGitment() {
    document.querySelector('#gitment_title').style.display = 'none';
    document.querySelector('#J_commentContainer').style.display = 'block';
    document.querySelector('#J_commentContainer').classList.add('gitment_container');
    var gitment = new Gitment({
        id: window.location.pathname,
        theme: myTheme,
        owner: 'cnt1992',
        repo: 'cnt1992.github.io',
        oauth: {
            client_id: '09b981847c8a38e58a62',
            client_secret: '1feb91ebe731e68f89af0e6c43928f5f61d0bbf9'
        }
    });
    gitment.render('J_commentContainer');
}</script><div class="copyright"><p>© 2015 - 2024 <a href="https://cnt1992.github.io">SkyCai</a>, Where there is a will there is a way.</p><p style="display:none !important;"><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span><span id="busuanzi_container_site_uv">本站总访客数<span id="busuanzi_value_site_uv"></span>人次</span></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-75181437-1",'auto');ga('send','pageview');</script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>